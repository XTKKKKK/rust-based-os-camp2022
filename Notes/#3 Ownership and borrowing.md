### 堆栈

**写入方面**：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

**读取方面**：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。



### 所有权原则

> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

#### 所有权交互：

1. 栈上变量 -> 直接拷贝复制。因为栈拷贝足够快，栈上数据也足够简单，直接自动拷贝会优于指针指向堆中内存。Rust的基本数据类型都是通过自动拷贝的方式赋值的。
2. 堆上变量 -> 所有权转移。不允许使用已经转移掉所有权的变量，以防二次释放的问题出现。

#### 克隆（深拷贝）

**Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小。

如果我们**确实**需要深度复制 `String` 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的方法。





### 引用和借用

Rust通过引用和借用来减少不必要的所有权转移

#### 引用和解引用

```Rust
fn main() {
    let x = 5;
  	//用&标注这是一个引用
    let y = &x;
    assert_eq!(5, x);
  	//用*来解引用
    assert_eq!(5, *y);
}
```

注意，&允许我们使用值，但没有赋予我们所有权。

#### 可变引用

```Rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

关于可变引用的几条规则：

- Rust在同一个作用域中只允许存在一个可变借用，这使得Rust在编译期间就可以避免数据竞争的出现。
- 可变引用和不可变引用不允许同时存在，这保证了每一份不可变引用的全生命周期都是安全的、不会被篡改的。
- 不允许返回悬垂引用（Dangling Reference），这保证了代码中不会有悬垂指针访问的问题。



#### NLL

在旧的Rust编译器中，引用和变量的作用域一致，这会导致一个尴尬的问题：

```Rust
fn main() {
   let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
  	//pos1
    let r3 = &mut s;
    println!("{}", r3);
	  //pos2
}
```

在老Rust编译其中，r1，r2，r3的作用域都在`pos2`结束，由于同一个作用域中不允许存在同一个变量的可变引用和不可变引用，因此这段代码会报错；
而在新的Rust编译器中，引入了`NLL(Non-Lexical Lifetime)`的优化，用于找到某个引用在作用域(`}`)结束前就不再被使用的代码位置。例如，r1,r2在pos1后就不再使用了，因此他们的作用域只到pos1，而r3的作用域则在pos1-pos2之间，他们的作用域不相交，不报错。
