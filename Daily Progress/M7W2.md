## 2022-7-11

æœ€è¿‘å·¥ä½œå®åœ¨å¤ªå¿™ï¼ŒåŒä¼‘æ—¥åˆå¿™ç€ç­¾è´­æˆ¿åˆåŒï¼Œå› æ­¤è¿ç»­å‡ å¤©éƒ½æ²¡æœ‰è¿›è¡Œrustçš„å­¦ä¹ ï¼Œä»Šå¤©ç»§ç»­ã€‚

ä»Šå¤©ç»“æŸäº†äº†Rustçš„ç¬¦åˆç±»å‹å’Œæµç¨‹æ§åˆ¶çš„å­¦ä¹ ï¼Œå­¦ä¹ äº†è¿­ä»£å™¨çš„ç”¨æ³•;å­¦ä¹ äº†æ¨¡å¼åŒ¹é…ã€‚å¤æ‚çš„æ¨¡å¼åŒ¹é…è®©ä»£ç æ›´åŠ ç®€æ´ã€ä¹Ÿåœ¨ä¸€å®šç¨‹åº¦ä¸Šä¿è¯äº†å®‰å…¨ã€‚

é™„ä¸¤ä¸ªä¹ é¢˜ï¼š

1. RuståŒ¹é…æ¨¡å¼

   ```rust
   /* ğŸŒŸğŸŒŸ ä½¿ç”¨æ¨¡å¼ &mut V å»åŒ¹é…ä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œä½ éœ€è¦æ ¼å¤–å°å¿ƒï¼Œå› ä¸ºåŒ¹é…å‡ºæ¥çš„ V æ˜¯ä¸€ä¸ªå€¼ï¼Œè€Œä¸æ˜¯å¯å˜å¼•ç”¨ */
   fn main() {
       let mut v = String::from("hello,");
       let r = &mut v;
   
       match r {
          //&mut value => value.push_str(" world!") é”™è¯¯ï¼åŒ¹é…ç»“æœæ˜¯å€¼è€Œéå¼•ç”¨
         value => value.push_str(" world!") //æ­£ç¡®ï¼Œç›´æ¥ä½¿ç”¨å¼•ç”¨
       }
   }
   ```

2. ç”¨æšä¸¾å®ç°é“¾è¡¨

   ```rust
   
   // å¡«ç©ºï¼Œè®©ä»£ç è¿è¡Œ
   use crate::List::*;
   
   enum List {
       // Cons: é“¾è¡¨ä¸­åŒ…å«æœ‰å€¼çš„èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ˜¯å…ƒç»„ç±»å‹ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯èŠ‚ç‚¹çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
       Cons(u32, Box<List>),
       // Nil: é“¾è¡¨ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºè¯´æ˜é“¾è¡¨çš„ç»“æŸ
       Nil,
   }
   // ä¸ºæšä¸¾å®ç°ä¸€äº›æ–¹æ³•
   impl List {
       // åˆ›å»ºç©ºçš„é“¾è¡¨
       fn new() -> List {
           // å› ä¸ºæ²¡æœ‰èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç›´æ¥è¿”å› Nil èŠ‚ç‚¹
           // æšä¸¾æˆå‘˜ Nil çš„ç±»å‹æ˜¯ List
           Nil
       }
       // åœ¨è€çš„é“¾è¡¨å‰é¢æ–°å¢ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¿”å›æ–°çš„é“¾è¡¨
       fn prepend(self, elem: u32) -> List {
           Cons(elem, Box::new(self))
       }
       // è¿”å›é“¾è¡¨çš„é•¿åº¦
       fn len(&self) -> u32 {
           match *self {
               // è¿™é‡Œæˆ‘ä»¬ä¸èƒ½æ‹¿èµ° tail çš„æ‰€æœ‰æƒï¼Œå› æ­¤éœ€è¦è·å–å®ƒçš„å¼•ç”¨
               Cons(_, ref tail) => 1 + tail.len(),
               // ç©ºé“¾è¡¨çš„é•¿åº¦ä¸º 0
               Nil => 0
           }
       }
       // è¿”å›é“¾è¡¨çš„å­—ç¬¦ä¸²è¡¨ç°å½¢å¼ï¼Œç”¨äºæ‰“å°è¾“å‡º
       fn stringify(&self) -> String {
           match *self {
               Cons(head, ref tail) => {
                   // é€’å½’ç”Ÿæˆå­—ç¬¦ä¸²
                   format!("{}, {}", head, tail.stringify())
               },
               Nil => {
                   format!("Nil")
               },
           }
       }
   }
   fn main() {
       // åˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨(ä¹Ÿæ˜¯ç©ºçš„)
       let mut list = List::new();
   
       // æ·»åŠ ä¸€äº›å…ƒç´ 
       list = list.prepend(1);
       list = list.prepend(2);
       list = list.prepend(3);
   
       // æ‰“å°åˆ—è¡¨çš„å½“å‰çŠ¶æ€
       println!("é“¾è¡¨çš„é•¿åº¦æ˜¯: {}", list.len());
       println!("{}", list.stringify());
   }
   
   ```

çœ‹åˆ°ä¸€ç¯‡æ–‡ç« ï¼Œææ„ã€éšå¼å€Ÿç”¨ã€refæ¨¡å¼ä¹‹é—´çš„å…³ç³»ï¼šhttps://medium.com/@robertgrosse/ref-patterns-destructuring-and-invisible-borrows-2f8ae6902656

